---
layout: post
title: 백준 2225 합분해
description: ''
sitemap: false
hide_last_modified: false
categories:
- algo

---
한줄요약: 점화식 생각해내기가 쉽지 않으면, 작은수의 예를 늘어 놓고(dp\[3\]\[2\], K = 3, N = 2) 차근차근 생각해보자. 그리고 dp배열의 디자인을 주어진 변수의 값을 가지고 생각하면(2개의 값이 주어지므로) 2차원 배열로 디자인해야 함을 착안할 수 있다.

[백준 2225 합분해](https://www.acmicpc.net/problem/2225)

* 주의사항
  * 최종값의 1000000000으로 나눈 값의 나머지가 출력임을 기억하자


  * 문제에서 위와 같은 mod 형식의 출력이 나올 경우 다음의 공식을 기억하자. x=a+b인 경우  x mod y  = a mod y + b mod y 

    즉, 더하기 전 값의 각각 값을 mod하고 더하면 최종 값의 mod 값이 된다. 

    > **즉 연산되는 연산자 모두가 mod 되어야 한다.**
  * mod 연산하기 전에 아래의 두식이 다름을 알자
    * sum += dp\[i - 1\]\[j - k\]) % MOD; (x)
      * 위가 에러나는 이유는 다음과 같다.
      * sum + dp\[i - 1\]\[j - k\]) % MOD 가 먼저 연산되고 그리고 결과값을 sum에 다시 대입하기 때문. 
      * mod 값을 일치 시키려면 피연산자 모두가 mod 되어야 하기 때문에 sum이 mod되지 않아서 에러가 떨어진다.
    * sum = (sum + dp\[i - 1\]\[j - k\]) % MOD; (o)

      이렇게 써야 에러가 나지 않는다.

* 접근방법

문제가 dp로 구분되어 있어서 dp를 적용해야 겠다는 생각이 들지만
문제 만약 처음 접했다면 dp로 접근했을지 의구심이 든다.

dp라고 해도 점화식이 언뜻 떠오르지 않아서 어려운 문제 중 하나.

2차원 배열의 dp를 생각해 내는 것이 풀이의 단초가 될 것이다.
dp\[3\]\[2\]은 K = 3, N = 2 즉 **3개의 수로 2을 만들 수 있는 경우의 수** 이므로
X + X + L = 2

![](/uploads/2022-04-10-002832.png)

L은 0부터 N까지 어떤 수든 될 수 있다. 그러므로 다음의 경우의 수들을 더한 것과 같다.

dp\[K-1\]\[N-0\]

dp\[K-1\]\[N-1\]

dp\[K-1\]\[N-2\]

그래서 점화식은

dp\[k\]\[n\] = dp\[k-1\]\[n-0\] + dp\[k-1\]\[n-1\] + ... + dp\[k-1\]\[n-n\]

이 된다.

* c++코드

```cpp
#include <bits/stdc++>
#define MOD 1000000000

using namespace std;
int n, k, i, j, l;

int dp[201][201];

int main() {
        cin >> n >> k;
      
        for (i = 0; i <= n; i++) {
            dp[0][i] = 0;
            dp[1][i] = 1;
        }
      
        for(i = 2; i <= k; i++) {
            for (j = 0; j <= n; j++) {
                for (l = 0; l <= j; l++) {
                    dp[i][j] = (dp[i][j] + dp[i-1][j-l]) % MOD;
                }
            }
        }
      
        cout << dp[k][n];
      
        return 0;

  }
```