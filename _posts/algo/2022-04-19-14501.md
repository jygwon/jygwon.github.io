---
layout: post
title: 백준 14501 퇴사
description: ''
sitemap: false
hide_last_modified: false
categories:
- algo
tags: dp
---
한줄요약: 돈을 벌기 위해서 퇴사날 까지 최대한 일할 수 있는 날을 계산하는 당신은 진정한 상남자!!

[퇴사](https://www.acmicpc.net/problem/14501)

보통 스케줄링이나 시간표 문제가 주어질 경우 그리디로 해결이 되는 경우가 있기 때문에, 본 문제도 접근방법을 그리디로 생각할 수 있는데, 아쉽게도 이 문제는 dp로 접근해야 한다.

**그 이유는** 그리디는 아무 값이나 뽑아서 대입할 수 있을 경우에만 적용할 수 있기 때문이다.

주어진 값을 차례대로 대입해서 해결해야 하는 경우는 dp의 향기를 느껴야한다. 다시 말하자면, **앞에서 주어진 조건에 따라서 뒤의 조건이 결정되기 때문에 dp로 접근해야 한다.**

본 문제는 2가지의 접근 방법이 있는데, 

1. 현재의 날짜에서 과거를 되집어 가면서 이날 일했다면? 이라는 생각으로 접근하는 것.
2. 주어진 값에서 오늘 무조건 일하거나 일하지 않는다면? 이라는 가정하면서 미래의 최대값을 계산해 가면서 접근하는 것.

***

1의 경우는 시간복잡도가 수열로 나타난다, 1+2+3..(n-1) + n

2개의 for문을 이용해서 i 날의 경우 j일에 일을 했을 경우와 안했을 경우를 되집에서 dp테이블을 만들게 된다.

    // i번째 날 일을하면 i + t[j]날 돈을 받기 때문에,
    // n+1번째 날까지 진행해줍니다.
    for(int i=1; i<=n + 1; i++){
    	for(int j=1; j<i; j++){
    	    // 1) j 번째 날에서 일을 안하고 i 번째 날까지 온 경우(j < i)
        	d[i] = max(d[i], d[j]);
            
        	// 2) j 번째 날에서 t[j] 기간 동안 일을하고 보상을 p[j] 받은 경우
            // 그 보상은 j + t[j] 날 받습니다.
            if(j + t[j] == i){
            	d[i] = max(d[i], d[j] + p[j]);
        	}        
        }
    }

***

2의 경우는 시간복잡도가 n으로 나타난다.

1개의 for문을 이용해서 i날의 경우 일을 했을 경우와 안했을 경우를 미래값의 dp에 업데이트 해준다. 즉 i날에서 t값을 계산해서 dp\[i+t\]의 값을 구해준다.

점화식은 아래와 같다.

     d[i]는 i번째 날에 받을 수 있는 최대 금액
     1) i번째 날에 일을 했을 경우
     d[i+t[i]] = max(d[i+t[i]], d[i] + p[i]);
    
     2) i번째 날에 일을 하지 않았을 경우
     d[i+1] = max(d[i+1], d[i]);

***

아래 코드는 2번의 경우로 푼 것이다.

```cpp
#include <stdio.h>

/*
시간 복잡도: O(n)
공간 복잡도: O(n)
사용한 알고리즘: 동적 계획법(bottom-up, tabulation)
사용한 자료구조: 1차원 배열
*/

const int kMaxCnt = 17;

/*
 d[i]는 i번째 날에 받을 수 있는 최대 금액
 1) i번째 날에 일을 했을 경우
 d[i+t[i]] = max(d[i+t[i]], d[i] + p[i]);

 2) i번째 날에 일을 하지 않았을 경우
 d[i+1] = max(d[i+1], d[i]);
 */
int n, t[kMaxCnt], p[kMaxCnt], d[kMaxCnt], result;

int max(int a, int b) {
	return a > b ? a : b;
}

int main() {
	//1. 문제 입력
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%d %d", &t[i], &p[i]);
	}

	// 2. DP 수행
	for (int i = 1; i <= n; i++) {
		// 1) i번째 날에 일을 했을 경우
		if (i + t[i] <= n + 1) {
			d[i + t[i]] = max(d[i + t[i]], d[i] + p[i]);
			// 최대값 갱신
			result = max(result, d[i + t[i]]);
		}

		// 2) i번째 날에 일을 하지 않았을 경우
		d[i + 1] = max(d[i + 1], d[i]);
		// 최대값 갱신
		result = max(result, d[i + 1]);
	}

	// 3. 출력
	printf("%d\n", result);
}
```
