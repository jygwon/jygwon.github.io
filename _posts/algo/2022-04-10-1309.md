---
layout: post
title: 백준 1309 동물원
description: ''
sitemap: false
hide_last_modified: false
categories:
- algo
tags: dp

---
한줄요약: 주어진 값이 1가지라도 dp를 2차원배열로 만들어 경우의 값을 따져보면 더 쉬운 점화식 도출이 가능하다.

[백준 1309 동물원](https://www.acmicpc.net/problem/1309)

일단 dp문제라는 감을 잡는 것이 중요하다.

조건은 연결된 가로나 세로에 사자를 모두 집어넣을 수 없다는 것.

마지막 조건인 9901로 나눈 나머지를 출력하는 것도 잊지 말자.

일단 dp배열의 차원과 (초기)값을 알아보자.

dp배열의 차원은, 우리의 크기인 n값만 주어지므로 1차원배열임을 알 수 있다.

dp배열의 값은 n개 우리에 집어넣을 수 있는 경우의 수이다.

그리고 n=1인 경우의 초기값은 아래와 같이 윗칸 아랫칸 안집어 넣을 때의 3가지 경우이다.

일단 두줄이면서 경우의 수를 모두 찾는 점을 보면 이전에 풀어보았던 [2xN 타일링](https://www.acmicpc.net/problem/11726) 문제와 비슷하다는 감을 잡을 수 있을 것이다. 벽돌 쌓기의 접근법을 떠올려보면 마지막에 가로나 세로 형태를 쌓을 수 있는 경우의 수를 기반으로 접근했었다. 마지막에 올 수 있는 경우의 수를 찾아보자.

![](/uploads/0blank.png)

n-1의 마지막을 위와 같이 3가지 경우로 나누어 보면 그 다음에 올 수 있는 경우의 수는

1. 아래쪽에 사자가 있을 경우 2가지
2. 위쪽에 사자가 있을 경우 2가지
3. 사자가 없을 경우 3가지가 된다.

이를 dp로 표현하면 주어진 값이 n개의 우리길이이기 때문에 1차원 배열이 아닐까 생각되지만 위와 같이 사자가 어느쪽에 있는지 경우의 수를 따져야 하므로 사자가 있는 우리의 값을 넣어주어 2차원 배열로 생각하면 아래와 같이 점화식 도출이 더 쉬워진다.

1번 경우: dp\[n\]\[0\] = dp\[n-1\]\[0\] + dp\[n-1\]\[1\] + dp\[n-1\]\[2\]

2번 경우: dp\[n\]\[1\] = dp\[n-1\]\[0\] + dp\[n-1\]\[2\];

3번 경우: dp\[n\]\[2\] = dp\[n-1\]\[0\] + dp\[n-1\]\[1\];

이걸로 핵심 코드를 만들어 보면 다음과 같다.

```cpp
for (int i = 2; i <= n; i++) { 
	dp[i][0] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]) % 9901; 
	dp[i][1] = dp[i - 1][0] + dp[i - 1][2] % 9901; 
	dp[i][2] = dp[i - 1][0] + dp[i - 1][1] % 9901; 
}
//각 연산때마다 9901로 나눠주지 않으면 오버플로난다.
```

그래서 최종 코드는 아래와 같다.

    #include <iostream>
    using namespace std;
    
    #define MOD 9901
     int N, i, ans;
     int dp[N+1][3];
        
    int main() {
    
        cin << N;
    
        dp[1][0] = 1, dp[1][1] = 1, dp[1][2] = 1;
        
        for (i = 2; i <= N; i++) {
            dp[i][0] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][2]) % MOD;
            dp[i][1] = (dp[i-1][0] + dp[i-1][2]) % MOD;
            dp[i][2] = (dp[i-1][0] + dp[i-1][1]) % MOD;
        }
    
        ans = (dp[N][0] + dp[N][1] + dp[N][2]) % MOD;
        
        coutn << ans;
        return 0;
    }